import tkinter as tk
from tkinter import scrolledtext, messagebox
import pandas as pd
import customtkinter as ctk
import re # Necesario para buscar números al inicio de la cadena

# Importaciones absolutas.
from modules.tabla_periodica import TablaPeriodica 
from modules.parser import parsear_ecuacion
from modules.balanceo import BalanceadorEcuacion
# Asumo que estas constantes y función existen en modules/utils.py
from modules.utils import NORMAL_TO_SUB, cargar_elementos, SUB_TO_NORMAL 

class Interfaz(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Balanceador de Ecuaciones Químicas (por Mínimos Cuadrados)")
        self.geometry("1100x800")
        self.state('zoomed')
        
        # Cargar datos para el tooltip
        self.df_elementos = cargar_elementos()
        
        self.crear_layout()

    def crear_layout(self):
        """Configura el layout principal usando grid."""
        
        # Configuración principal del grid (reorganizada para evitar solapamientos)
        # Filas: 0 = tabla periódica (grande), 1 = entrada (fija), 2 = resultado, 3 = lewis (grande al final)
        self.grid_rowconfigure(0, weight=0, minsize=210)
        self.grid_rowconfigure(1, weight=0, minsize=160)
        self.grid_rowconfigure(2, weight=1, minsize=300)
        self.grid_columnconfigure(0, weight=1)

        # --- Frame Principal de la Tabla (Fila 0) ---
        self.frame_top = tk.Frame(self, bg='#CFD8DC')
        self.frame_top.grid(row=0, column=0, sticky="nsew", padx=5, pady=(5,1))

        self.frame_middle = tk.Frame(self) # Frame invisible contenedor
        self.frame_middle.grid(row=1, column=0, sticky="nsew", padx=5, pady=1)
        self.frame_middle.grid_columnconfigure(0, weight=3) 
        self.frame_middle.grid_columnconfigure(1, weight=2)
        self.frame_middle.grid_rowconfigure(0, weight=1)
        
        # Dentro de frame_top la columna 0 es el panel de info y la 1 la tabla (expandible)
        self.frame_top.grid_columnconfigure(0, weight=0, minsize=160) # panel información ancho fijo
        self.frame_top.grid_columnconfigure(1, weight=1) # tabla ocupa el resto
        self.frame_top.grid_rowconfigure(0, weight=1) 
        
        # Tooltip para info de elemento (Columna 0)
        self.frame_info = tk.Label(self.frame_top, text="Clic en un elemento\npara ver detalles.", 
                                 bg='#EFEFEF', bd=1, relief=tk.SOLID, justify=tk.LEFT,
                                 font=('Helvetica', 10), anchor='nw', width=28, height=8, 
                                 padx=8, pady=8)
        self.frame_info.grid(row=0, column=0, sticky="nsw", padx=10, pady=10)

        # --- Tabla Periódica --- (Columna 1)
        self.tabla_periodica = TablaPeriodica(self.frame_top, click_callback=self.evento_click_elemento, hover_callback=self.actualizar_panel_info)
        self.tabla_periodica.grid(row=0, column=1, sticky="nsew", padx=6, pady=6) 

        # --- Frame de Entrada de Ecuación (Fila 1) CustomTKinter---
        self.frame_input = ctk.CTkFrame(
            master=self.frame_middle,
            fg_color='#B0BEC5',    # Reemplaza a 'bg'. Es el color de fondo del frame.
            corner_radius=20,      # <--- ¡LA MAGIA! Bordes redondeados. # Opcional: color del borde un poco más oscuro.
            )

# La colocación (grid) funciona casi igual, pero se ve mejor
        self.frame_input.grid(
            row=0, 
            column=0, 
            sticky="nsew", # "ew" hace que se estire de Este a Oeste (ancho completo)
            padx=(0, 5),     # Margen externo (separación de los bordes de la ventana)
            pady=0      # Margen vertical
            )

# Esto se mantiene igual (es para centrar o expandir elementos dentro)
        self.frame_input.grid_columnconfigure(0, weight=1)
        
        lbl_EcuacionQ=ctk.CTkLabel(
            master=self.frame_input,
            corner_radius=20,
            text="Ecuación Química",
            text_color="#000000",
            font=("Roboto Bold",24)
        )
        lbl_EcuacionQ.grid(row=0, column=0, columnspan=10, pady=2)

# Recuerden gente, todo eso de arriba solo con Custom TKinter --Sgt.Aldea---

        # Campo de entrada de la ecuación
        self.ecuacion_var = tk.StringVar(value="") 
        self.entry_ecuacion = tk.Entry(self.frame_input, textvariable=self.ecuacion_var, font=('Helvetica', 12), width=35, bd=2, relief=tk.SUNKEN)
        self.entry_ecuacion.grid(row=1, column=0, columnspan=10, padx=5, pady=5, sticky="ew")
        
        # Frame para el constructor de la ecuación
        self.frame_constructor = tk.Frame(self.frame_input, bg='#B0BEC5')
        self.frame_constructor.grid(row=2, column=0, columnspan=10, pady=5, sticky="ew")
        self.frame_constructor.grid_columnconfigure((0,1,2,3,4), weight=1)
        
        lbl_mol = tk.Label(self.frame_constructor, text="Molécula:", font=('Helvetica', 11), bg='#B0BEC5')
        lbl_mol.grid(row=0, column=0, padx=5, pady=5, sticky="e")
        self.molecula_var = tk.StringVar(value="") 
        self.molecula_var.trace_add('write', self.convertir_a_subindices)
        self.entry_molecula = tk.Entry(self.frame_constructor, textvariable=self.molecula_var, font=('Helvetica', 11), width=12, bd=1)
        self.entry_molecula.grid(row=0, column=1, padx=5, pady=5, sticky="w")

        
        # --- BOTONES DE OPERACIÓN | Los cambie de Tkinter a CustomTkinter --Sgt.Aldea---
        btn_agregar = ctk.CTkButton(
            master=self.frame_constructor, text="Agregar (+)",
            fg_color="#1E88E5", hover_color="#1565C0",
            corner_radius=15, height=30, width=100, # Un poco más compactos
            command=self.agregar_molecula
        )
        btn_agregar.grid(row=0, column=2, padx=5, pady=5)

        btn_flecha = ctk.CTkButton(
            master=self.frame_constructor, text="Flecha (→)",
            fg_color="#FFC107", hover_color="#C09000",
            corner_radius=15, height=30, width=100,
            command=self.agregar_flecha
        )
        btn_flecha.grid(row=0, column=3, padx=5, pady=5)

        btn_limpiar = ctk.CTkButton(
            master=self.frame_constructor, text="Limpiar",
            fg_color="#E34234", hover_color="#BE3A2E",
            corner_radius=15, height=32, width=110,
            command=self.limpiar_ecuacion
        )
        btn_limpiar.grid(row=1, column=1, padx=5, pady=(2,5))
        
        btn_balancear = ctk.CTkButton(
            master=self.frame_constructor, text="Balancear",
            fg_color="#00A86B", hover_color="#027E50",
            corner_radius=15, height=32, width=110, font=("Roboto", 13, "bold"),
            command=self.balancear_ecuacion
        )
        btn_balancear.grid(row=1, column=2, padx=5, pady=(2,5))
        btn_lewis = ctk.CTkButton(
            master=self.frame_constructor, text="Ver Lewis", # Texto más corto
            fg_color="#9C27B0", hover_color="#751E85",
            corner_radius=15, height=32, width=110,
            command=self.mostrar_lewis_actual
        )
        btn_lewis.grid(row=1, column=3, padx=5, pady=(2,5))

        # --- Frame de Resultado (Fila 2) ---
        self.frame_bottom = tk.Frame(self.frame_middle, bg='#ECEFF1', padx=10, pady=10)
        self.frame_bottom.grid(row=0, column=1, sticky="nsew", padx=(5, 0), pady=0)
        self.frame_bottom.grid_columnconfigure(0, weight=1)
        self.frame_bottom.grid_rowconfigure(1, weight=1)

        tk.Label(self.frame_bottom, text="Procedimiento y Resultado", font=('Helvetica', 14, 'bold'), bg='#ECEFF1').grid(row=0, column=0, sticky="w", pady=(0, 5))
        
        self.output_text = scrolledtext.ScrolledText(self.frame_bottom, wrap=tk.WORD, height=6, font=('Consolas', 11), bd=2, relief=tk.SUNKEN)
        self.output_text.grid(row=1, column=0, sticky="nsew")

        # --- NUEVO FRAME PARA ESTRUCTURA DE LEWIS (Fila 3, al final) ---
        self.frame_lewis = tk.Frame(self, bg='#DDE3E8', padx=5, pady=5)
        self.frame_lewis.grid(row=2, column=0, sticky="nsew", padx=5, pady=(1,5))

        # Configuración de columnas y filas internas (más espacio para 3D)
        self.frame_lewis.grid_columnconfigure(0, weight=1)
        self.frame_lewis.grid_columnconfigure(1, weight=2)
        self.frame_lewis.grid_rowconfigure(0, weight=0, minsize=30) 
        # Fila 1: Contenido (peso 1 = ocupa todo el resto del espacio)
        self.frame_lewis.grid_rowconfigure(1, weight=1)

        # --- Título del panel de Lewis ---
        self.label_lewis_title = tk.Label(
            self.frame_lewis,
            text="Estructura de Lewis (2D) y Modelo (3D)",
            font=('Helvetica', 12, 'bold'),
            bg='#DDE3E8'
        )
        self.label_lewis_title.grid(row=0, column=0, columnspan=2, pady=(2,5), sticky="n")

        # --- Canvas 2D de Lewis (expandible) ---
        self.canvas_2d = tk.Canvas(
            self.frame_lewis,
            bg="white",
            highlightthickness=1,
            highlightbackground="#AAAAAA"
        )
        self.canvas_2d.grid(row=1, column=0, sticky="nsew", padx=5, pady=0)

        # --- Frame donde irá el modelo 3D (VTK) ---
        self.frame_3d = tk.Frame(self.frame_lewis, bg="black")
        self.frame_3d.grid(row=1, column=1, sticky="nsew", padx=2, pady=0)

    # --- Generador simple de geometría a partir de fórmula (heurístico) ---
    def formula_a_atoms_bonds(self, formula_norm):
        """
        Entrada: formula_norm tipo 'H2O' (sin subíndices unicode).
        Salida:
          atoms_2d: [{'elem': 'O', 'x':..., 'y':...}, ...]
          atoms_3d: [{'elem':'O', 'pos':(x,y,z)}, ...]
          bonds: [(i,j,order), ...]
        Este generador es heurístico y funciona bien para moléculas sencillas.
        """
        import re, math
        tokens = re.findall(r'([A-Z][a-z]?)(\d*)', formula_norm)
        atoms = []
        for sym, num in tokens:
            n = int(num) if num else 1
            for _ in range(n):
                atoms.append(sym.capitalize())
        if 'C' in atoms:
            central_idx = atoms.index('C')
        else:
            non_h = [i for i,a in enumerate(atoms) if a != 'H']
            central_idx = non_h[0] if non_h else 0

        bonds = []
        for i in range(len(atoms)):
            if i == central_idx:
                continue
            bonds.append((central_idx, i, 1))

        atoms_2d = []
        radius = 120
        cx, cy = 200, 150
        n_subs = len(atoms) - 1
        for i, elem in enumerate(atoms):
            if i == central_idx:
                atoms_2d.append({'elem': elem, 'x': cx, 'y': cy})
            else:
                idx = i if i < central_idx else i-1
                theta = 2*math.pi * (idx / max(1, n_subs))
                x = cx + radius * math.cos(theta)
                y = cy + radius * math.sin(theta)
                atoms_2d.append({'elem': elem, 'x': x, 'y': y})

        atoms_3d = []
        for i, elem in enumerate(atoms):
            if i == central_idx:
                atoms_3d.append({'elem': elem, 'pos': (0.0, 0.0, 0.0)})
            else:
                angle = 2*math.pi*(i / max(1, len(atoms)))
                r = 1.2
                z = 0.0 if len(atoms) <= 3 else (0.2 * ( (i%2)*2 -1 ))
                atoms_3d.append({'elem': elem, 'pos': (r*math.cos(angle), r*math.sin(angle), z)})
        return atoms_2d, atoms_3d, bonds

    # --- Dibujar en Canvas 2D ---
    def dibujar_2d_en_canvas(self, atoms_2d, bonds):
        """
        Dibuja la estructura en canvas escalada y con aspecto más profesional:
        - centra y escala automáticamente
        - dibuja sombras / bordes de los átomos
        - dibuja líneas paralelas para dobles/triples enlaces
        - etiqueta cada átomo con símbolo y (si está disponible) número atómico pequeño
        """
        self.canvas_2d.delete("all")
        self.canvas_2d.update_idletasks()
        canvas_w = max(220, self.canvas_2d.winfo_width())
        canvas_h = max(140, self.canvas_2d.winfo_height())
        padding = 18

        if not atoms_2d:
            return

        # bounding box del contenido original
        xs = [a['x'] for a in atoms_2d]
        ys = [a['y'] for a in atoms_2d]
        minx, maxx = min(xs), max(xs)
        miny, maxy = min(ys), max(ys)
        content_w = maxx - minx if maxx > minx else 1.0
        content_h = maxy - miny if maxy > miny else 1.0

        # escala para ajustar al canvas — limitamos el zoom máximo para mantener proporciones
        scale_x = (canvas_w - 2 * padding) / content_w
        scale_y = (canvas_h - 2 * padding) / content_h
        scale = min(scale_x, scale_y, 1.4)

        # origen y centro
        cx_orig = (minx + maxx) / 2.0
        cy_orig = (miny + maxy) / 2.0
        cx_canvas = canvas_w / 2.0
        cy_canvas = canvas_h / 2.0

        # transformar coordenadas
        atoms_t = []
        for a in atoms_2d:
            tx = cx_canvas + (a['x'] - cx_orig) * scale
            ty = cy_canvas + (a['y'] - cy_orig) * scale
            atoms_t.append({'elem': a['elem'], 'x': tx, 'y': ty})

        # Mapa de colores para átomos (mejor apariencia)
        atom_color = {
            "H": "#FFFFFF", "C": "#333333", "O": "#FF3B30", "N": "#007AFF",
            "S": "#FFD60A", "Cl": "#00C853", "F": "#00C853", "P": "#FF9500"
        }

        # Función para dibujar enlaces considerandos orden (1,2,3)
        import math
        def draw_bond(p1, p2, order):
            x1, y1 = p1; x2, y2 = p2
            dx, dy = x2 - x1, y2 - y1
            length = math.hypot(dx, dy)
            if length == 0:
                return
            ux, uy = dx / length, dy / length
            # perpendicular
            px, py = -uy, ux
            # offsets para enlaces múltiples
            offset = max(3, 6 * (scale/1.2))
            if order == 1:
                self.canvas_2d.create_line(x1, y1, x2, y2, width=max(1, int(2*scale)), capstyle=tk.ROUND)
            else:
                # dibuja líneas paralelas centradas
                offs = offset * (order - 1)
                # para doble: -offset/2, +offset/2 ; triple: -offset, 0, +offset
                steps = []
                if order == 2:
                    steps = [-offset/2, offset/2]
                elif order == 3:
                    steps = [-offset, 0, offset]
                for s in steps:
                    sx1 = x1 + px * s; sy1 = y1 + py * s
                    sx2 = x2 + px * s; sy2 = y2 + py * s
                    self.canvas_2d.create_line(sx1, sy1, sx2, sy2, width=max(1, int(1.6*scale)), capstyle=tk.ROUND)

        # Dibujar enlaces primero (para que queden debajo)
        for i, j, order in bonds:
            if i < 0 or j < 0 or i >= len(atoms_t) or j >= len(atoms_t):
                continue
            a = atoms_t[i]; b = atoms_t[j]
            draw_bond((a['x'], a['y']), (b['x'], b['y']), order)

        # Dibujar átomos: sombra, borde, interior, etiqueta y número atómico pequeño
        for idx, a in enumerate(atoms_t):
            x = a['x']; y = a['y']
            elem = a['elem']
            # radio relativo
            base_r = max(8, 14 * scale)
            # sombra (dibujar varios óvalos ligeramente más grandes para efecto sutil)
            try:
                # sombra: óvalo gris muy tenue
                self.canvas_2d.create_oval(x-base_r-2, y-base_r-2, x+base_r+2, y+base_r+2, fill="#E6E6E6", outline="")
            except Exception:
                pass

            fill = atom_color.get(elem, "#B0BEC5")
            # círculo principal (blanco para H para mayor identificación)
            if elem == "H":
                fill = atom_color.get("H", "#FFFFFF")
            self.canvas_2d.create_oval(x-base_r, y-base_r, x+base_r, y+base_r, fill=fill, outline="#222222", width=max(1, int(1.5*scale)))

            # Texto del símbolo centrado
            font_size = max(9, int(12 * scale))
            self.canvas_2d.create_text(x, y-1, text=elem, font=("Helvetica", font_size, "bold"))

            # Número atómico pequeño debajo si está disponible en self.df_elementos
            try:
                if hasattr(self, "df_elementos") and self.df_elementos is not None:
                    df = self.df_elementos
                    row = df[df["Simbolo"] == elem]
                    if not row.empty:
                        z = int(row["NumeroAtomico"].values[0])
                        self.canvas_2d.create_text(x, y + base_r - 6, text=str(z), font=("Helvetica", max(6, int(8*scale))), fill="#333333")
            except Exception:
                pass

        # Dibujar borde decorativo alrededor del canvas (opcional estético)
        self.canvas_2d.create_rectangle(2, 2, canvas_w-2, canvas_h-2, outline="#CCCCCC")

    # --- INICIALIZAR VTK EN self.frame_3d ---
    def init_vtk_3d(self):
        try:
            from vtkmodules.vtkRenderingCore import vtkRenderer
            from vtkmodules.vtkCommonTransforms import vtkTransform
            from vtkmodules.vtkFiltersSources import vtkSphereSource, vtkCylinderSource
            from vtkmodules.vtkRenderingCore import vtkActor, vtkPolyDataMapper
            from vtkmodules.vtkInteractionStyle import vtkInteractorStyleTrackballCamera
            from vtkmodules.tk.vtkTkRenderWindowInteractor import vtkTkRenderWindowInteractor
        except Exception as e:
            messagebox.showerror("VTK no disponible", f"Error importando VTK: {e}")
            return

        self.vtk_renderer = vtkRenderer()
        self.vtk_renderer.SetBackground(1.0, 1.0, 1.0)

        self.vtk_widget = vtkTkRenderWindowInteractor(self.frame_3d, width=400, height=300)
        self.vtk_widget.pack(fill="both", expand=True)
        self.vtk_widget.GetRenderWindow().AddRenderer(self.vtk_renderer)

        self.interactor = self.vtk_widget.GetRenderWindow().GetInteractor()
        style = vtkInteractorStyleTrackballCamera()
        self.interactor.SetInteractorStyle(style)
        self.vtk_widget.Initialize()
        self.vtk_widget.Start()

        self._vtk_actors = []
        

    # --- Limpiar escena VTK ---
    def clear_vtk_scene(self):
        for actor in getattr(self, "_vtk_actors", []):
            self.vtk_renderer.RemoveActor(actor)
        self._vtk_actors = []
        if hasattr(self, 'vtk_widget'):
            self.vtk_widget.GetRenderWindow().Render()

    # --- Render Ball-and-stick 3D con VTK ---
    def render_molecule_3d(self, atoms3d, bonds):
        from vtkmodules.vtkRenderingCore import vtkActor, vtkPolyDataMapper
        from vtkmodules.vtkFiltersSources import vtkSphereSource, vtkCylinderSource
        from vtkmodules.vtkCommonTransforms import vtkTransform
        import math
        import numpy as _np

        self.clear_vtk_scene()

        radius_map = {"H":0.2, "C":0.35, "O":0.33, "N":0.33, "S":0.4}
        color_map = {"H":(1,1,1), "C":(0.2,0.2,0.2), "O":(1,0,0), "N":(0,0,1), "S":(1,1,0)}

        for a in atoms3d:
            elem = a.get("elem","X"); pos = a.get("pos",(0,0,0))
            r = radius_map.get(elem, 0.3)
            sphere = vtkSphereSource()
            sphere.SetCenter(pos)
            sphere.SetRadius(r)
            sphere.SetThetaResolution(24); sphere.SetPhiResolution(24)
            sphere.Update()

            mapper = vtkPolyDataMapper()
            mapper.SetInputConnection(sphere.GetOutputPort())
            actor = vtkActor()
            actor.SetMapper(mapper)
            actor.GetProperty().SetColor(color_map.get(elem, (0.5,0.5,0.5)))
            self.vtk_renderer.AddActor(actor)
            self._vtk_actors.append(actor)

        for i,j,order in bonds:
            p1 = _np.array(atoms3d[i]['pos']); p2 = _np.array(atoms3d[j]['pos'])
            v = p2 - p1
            length = _np.linalg.norm(v)
            if length == 0: continue
            center = tuple((p1 + p2) / 2.0)
            cyl = vtkCylinderSource()
            cyl.SetResolution(24)
            cyl.SetRadius(0.08 * order)
            cyl.SetHeight(length)
            cyl.Update()

            transform = vtkTransform()
            transform.Translate(center)
            v1 = _np.array([0.0, 1.0, 0.0])
            v2 = v / length
            axis = _np.cross(v1, v2)
            if _np.linalg.norm(axis) > 1e-6:
                angle = math.degrees(math.acos(max(-1.0, min(1.0, float(_np.dot(v1, v2))))))
                transform.RotateWXYZ(angle, axis[0], axis[1], axis[2])

            mapper = vtkPolyDataMapper()
            mapper.SetInputConnection(cyl.GetOutputPort())
            actor = vtkActor()
            actor.SetMapper(mapper)
            actor.SetUserTransform(transform)
            actor.GetProperty().SetColor(0.7,0.7,0.7)

            self.vtk_renderer.AddActor(actor)
            self._vtk_actors.append(actor)

        self.vtk_widget.GetRenderWindow().Render()

    def _validar_molecula_sin_coeficiente(self, molecula_normal: str) -> bool:
        """
        Devuelve True si la molécula NO tiene coeficiente al inicio.
        Ej: "CH4" -> True, "2CH4" -> False
        """
        if not molecula_normal:
            return False
        if re.match(r'^\d+', molecula_normal):
            return False
        return True
        
    def calcular_propiedades_molecula(self, formula_norm, atoms_2d, atoms_3d, bonds):
        """
        Genera un texto breve (apto para estudiantes de enseñanza media)
        con las características principales de la molécula.
        - formula_norm: cadena normal (ej. CH4)
        - atoms_2d: lista de dicts {'elem': 'C', 'x':..., 'y':...}
        - atoms_3d: lista de dicts {'elem': 'C', 'pos':(...)}
        - bonds: lista de tuplas (i, j, order)
        """
        from collections import Counter
        import numpy as _np

        # Mapa simple de electrones de valencia (fallback)
        VALENCE = {
            "H": 1, "He": 2,
            "Li": 1, "Be": 2, "B": 3, "C": 4, "N": 5, "O": 6, "F": 7, "Ne": 8,
            "P": 5, "S": 6, "Cl": 7, "Br": 7, "I": 7
        }

        # Conteos y resumen de tipos de enlace
        bond_orders = [int(order) if order is not None else 1 for (_, _, order) in bonds]
        total_bonds = len(bonds)
        singles = sum(1 for o in bond_orders if o == 1)
        doubles = sum(1 for o in bond_orders if o == 2)
        triples = sum(1 for o in bond_orders if o >= 3)
        total_pairs_in_bonds = sum(bond_orders)  # cada 'order' representa pares (1 = 1 par = 2 e-)

        lines = []
        lines.append(f"Fórmula: {formula_norm}")
        lines.append("")  # separador breve

        # --- Tipo y número de enlaces (breve) ---
        lines.append("Tipo y número de enlaces:")
        if total_bonds == 0:
            lines.append("  - No se detectaron enlaces.")
        else:
            types = []
            if singles:
                types.append(f"{singles} simple(s)")
            if doubles:
                types.append(f"{doubles} doble(s)")
            if triples:
                types.append(f"{triples} triple(s)")
            types_str = ", ".join(types)
            # Ejemplo didáctico corto
            example = ""
            if "C" in [a["elem"] for a in atoms_2d] and "O" in [a["elem"] for a in atoms_2d] and doubles:
                example = " Ej.: en CO₂ hay dos enlaces dobles."
            lines.append(f"  - {types_str}.{example}")
            lines.append(f"  - Enlaces totales: {total_bonds}")
            lines.append(f"  - Pares de electrones compartidos en enlaces: {total_pairs_in_bonds} (cada par = 2 e-)")
        lines.append("")

        # --- Electrones de valencia y pares enlazantes/solitarios (estimados) ---
        lines.append("Configuración y valencia (resumen por átomo):")
        elems = [a["elem"] for a in atoms_2d]
        counts = Counter(elems)

        # Construir grado (número de enlaces por átomo, considerando orden)
        degs = [0] * len(atoms_2d)
        for i, j, order in bonds:
            o = int(order) if order is not None else 1
            degs[i] += o
            degs[j] += o

        # Para cada átomo, calculamos una estimación sencilla:
        # - valence = VALENCE lookup (si no existe, se intenta con df_elementos)
        # - electrons_in_bonds = degs[idx] * 2 (pares->electrones alrededor por enlaces)
        # - lone_electrons_est = valence - degs[idx]  (si positivo) *esto estima pares no enlazantes en electrones
        # Nota pedagógica: esta es una estimación simple para explicar el concepto al estudiante.
        for idx, a in enumerate(atoms_2d):
            sym = a.get("elem", "?")
            val = VALENCE.get(sym, None)
            if val is None:
                # intentar sacar masa/número desde self.df_elementos si existe (no perfecto pero ayuda)
                try:
                    if hasattr(self, "df_elementos") and self.df_elementos is not None:
                        row = self.df_elementos[self.df_elementos["Simbolo"] == sym]
                        if not row.empty and "NumeroAtomico" in row.columns:
                            # aproximamos valencia por grupo (heurística): usar (NumeroAtomico % 8) como fallback
                            z = int(row["NumeroAtomico"].values[0])
                            val = z % 8
                            if val == 0:
                                val = 8
                        else:
                            val = 0
                    else:
                        val = 0
                except Exception:
                    val = 0

            bonds_count = degs[idx]
            # electrons used in bonds around atom (en pares -> *2 para electrons)
            electrons_around_from_bonds = bonds_count * 2
            # Estimamos electrones no enlazantes en electrones:
            lone_elec = val - bonds_count
            if lone_elec < 0:
                lone_elec = 0
            # convertir a pares de electrones no enlazantes
            lone_pairs = lone_elec // 2 if lone_elec >= 2 else (1 if lone_elec == 1 else 0)
            # Electrones totales alrededor (estimación Lewis): (bonds*2) + (lone_pairs*2)
            electrons_around = electrons_around_from_bonds + (lone_pairs * 2)

            # Regla sencilla de estabilidad: H -> 2, resto -> 8
            target = 2 if sym == "H" else 8
            meets = "Sí" if electrons_around == target else "No (estimado)"

            # Texto compacto y didáctico
            lines.append(f"  - {sym}: valencia ≈ {val}e-, enlaces ≈ {bonds_count}, pares solitarios ≈ {lone_pairs}. Cumple regla ({target}): {meets}")

        lines.append("")

        # Notas finales cortas y amigables
        lines.append("")
        lines.append("Notas (para estudiantes):")
        lines.append("  - Cada línea = 1 par de electrones (2 e-). Doble = 2 pares, triple = 3 pares.")
        lines.append("  - La regla del octeto significa tener ~8 electrones alrededor (H solo 2).")
        lines.append("  - Esta es una explicación simplificada para aprender la idea; estructuras reales pueden tener excepciones.")

        # Unir y retornar (texto corto, con saltos)
        return "\n".join(lines)

    

    # --- Botón / función que conecta todo: obtiene la molécula del entry y dibuja ---
    def mostrar_lewis_actual(self):
        """
        Obtiene la molécula del campo, dibuja 2D y 3D y escribe propiedades en el panel de salida.
        Esta versión es más robusta: captura errores parciales (p. ej. VTK no disponible)
        y se asegura de que el texto se inserte y sea visible.
        """
        mol_unicode = self.molecula_var.get().strip()
        mol_norm = mol_unicode.translate(SUB_TO_NORMAL)

        if not mol_norm:
            messagebox.showinfo("Info", "Escribe una molécula en el campo 'Molécula' (ej: CH4) y pulsa Ver Lewis.")
            return

        # Validación: evitar coeficientes en el campo 'Molécula' (ej: "2CH4")
        if not self._validar_molecula_sin_coeficiente(mol_norm):
            messagebox.showwarning(
                "Formato inválido",
                "Por favor ingresa una molécula estable en el campo 'Molécula' (ej: CH4). "
                "No escribas coeficientes al inicio (por ejemplo: 2CH4)."
            )
            return

        # Generar geometría (puede lanzar si formula no parsea bien)
        try:
            atoms_2d, atoms_3d, bonds = self.formula_a_atoms_bonds(mol_norm)
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo generar la geometría para '{mol_norm}': {e}")
            return

        # Dibujar 2D (esto ya lo tienes)
        try:
            self.dibujar_2d_en_canvas(atoms_2d, bonds)
        except Exception as e:
            # No queremos que un fallo visual impida mostrar las propiedades
            print(f"[DEBUG] Error al dibujar 2D: {e}")

        # Intentar inicializar VTK y renderizar 3D, pero no bloquear si falla
        try:
            if not hasattr(self, 'vtk_widget'):
                self.init_vtk_3d()
            # Si init falló, init_vtk_3d muestra un messagebox y sale; comprobamos vtk_widget
            if hasattr(self, 'vtk_widget'):
                try:
                    self.render_molecule_3d(atoms_3d, bonds)
                except Exception as e:
                    print(f"[DEBUG] Error al renderizar 3D: {e}")
        except Exception as e:
            # Capturamos cualquier otro fallo de VTK sin interrumpir la UI
            print(f"[DEBUG] Excepción al manejar VTK: {e}")

        # Asegurarnos de que el widget de salida esté en modo normal (editable) para insertar texto
        try:
            self.output_text.configure(state='normal')
        except Exception:
            pass

        # Calcular propiedades y escribir en el panel de resultado
        try:
            props = self.calcular_propiedades_molecula(mol_norm, atoms_2d, atoms_3d, bonds)
            # Opcional: limpiar el output anterior o no — aquí añadimos al final.
            self.output_text.insert(tk.END, "=== Propiedades de la molécula ===\n")
            self.output_text.insert(tk.END, props + "\n")
            self.output_text.insert(tk.END, "=== Fin propiedades ===\n\n")
            # Mover el scroll al final para que el usuario lo vea
            self.output_text.see(tk.END)
        except Exception as e:
            # Si el cálculo de propiedades falla, insertamos la mínima info útil
            try:
                self.output_text.insert(tk.END, f"Mostrar Lewis: {mol_norm} | átomos: {len(atoms_2d)} | enlaces: {len(bonds)}\n")
                self.output_text.insert(tk.END, f"(Error al calcular propiedades: {e})\n")
                self.output_text.see(tk.END)
            except Exception:
                # Si falla hasta aquí, al menos no dejamos que la app se cierre
                print(f"[DEBUG] Error al insertar texto en output_text: {e}")

        # Opcional: dejar el output_text en modo normal (permitir copia), pero si quieres bloquearlo:
        try:
            # self.output_text.configure(state='disabled')  # descomenta si quieres que sea sólo lectura
            pass
        except Exception:
            pass

    
    def convertir_a_subindices(self, *args):
        """
        Función de rastreo (trace) que se llama cada vez que cambia self.molecula_var.
        Busca números y aplica subíndices, pero protege los coeficientes al inicio.
        """
        current_value_unicode = self.molecula_var.get()
        
        # 1. Revertir cualquier subíndice Unicode a número normal para poder procesarlo
        current_value_normal = current_value_unicode.translate(SUB_TO_NORMAL)
        
        # 2. Intentar separar el Coeficiente (inicio) de la Molécula (resto)
        # ^(\d*) busca 0 o más dígitos al inicio (el coeficiente)
        match = re.match(r'^(\d*)(.*)$', current_value_normal)
        
        new_value_unicode = current_value_unicode # Inicializamos con el valor actual

        if match:
            coef = match.group(1) # Coeficiente (se mantiene normal)
            mol = match.group(2)  # Molécula (aquí aplicamos subíndices)
            
            # Convertir los dígitos de la molécula a subíndices
            mol_subscripted = mol.translate(NORMAL_TO_SUB)
            
            # Recomponer el valor: Coeficiente Normal + Molécula Subíndice
            new_value_unicode = coef + mol_subscripted
        else:
             # Caso de seguridad: si no hay un match claro, solo intenta convertir todo (como antes)
             new_value_unicode = current_value_normal.translate(NORMAL_TO_SUB) 

        # 3. Quitar el rastreador temporalmente para evitar un bucle infinito
        # Obtenemos el ID del rastreador actual para removerlo
        try:
             # Esto obtiene el ID del primer rastreador 'write'
             trace_id = self.molecula_var.trace_info()[0][1]
        except IndexError:
            # A veces trace_info está vacío al inicio, lo ignoramos y seguimos
            trace_id = None
            
        if trace_id:
            self.molecula_var.trace_remove('write', trace_id)
        
        # 4. Actualizar la variable si hay un cambio
        if new_value_unicode != current_value_unicode:
            self.molecula_var.set(new_value_unicode)
            
            # Mover el cursor al final
            self.entry_molecula.icursor(tk.END)

        # 5. Volver a añadir el rastreador
        if trace_id:
            self.molecula_var.trace_add('write', self.convertir_a_subindices)
        
    
    def actualizar_panel_info(self, elemento_info):
        """
        Actualiza el tooltip con la información detallada del elemento
        Y añade el SÍMBOLO al campo de la molécula, manteniendo la lógica de subíndices.
        """
        simbolo = elemento_info['Simbolo']
    
        nombre = elemento_info['Nombre']
        numero_atomico = elemento_info['NumeroAtomico']
        masa_atomica = elemento_info['MasaAtomica']
        tipo = elemento_info['TipoElemento']
        
        info = (
            f"{nombre} ({simbolo})\n"
            f"Z: {numero_atomico} | Masa: {masa_atomica}\n"
            f"Tipo: {tipo}"
        )
        self.frame_info.config(text=info)

    def evento_click_elemento(self, elemento_info):

        # 1. Actualizamos info
        self.actualizar_panel_info(elemento_info)

        # 2. Escribimos en el input
        simbolo = elemento_info['Simbolo']
        current_molecula = self.molecula_var.get()
        current_molecula_normal = current_molecula.translate(SUB_TO_NORMAL)
        new_normal = current_molecula_normal + simbolo
        
        # Usamos la lógica de conversión
        self.molecula_var.set(new_normal.translate(NORMAL_TO_SUB))
        self.entry_molecula.focus_set()


    def agregar_molecula(self):
        """
        Añade la molécula del entry al campo de la ecuación, seguida de un '+'.
        *** AQUÍ APLICAMOS SUBÍNDICES AL CAMPO DE LA ECUACIÓN ***
        """
        molecula_unicode = self.molecula_var.get().strip()
        
        # Para el motor de balanceo, necesitamos la versión NORMAL (ej. H2O)
        molecula_normal = molecula_unicode.translate(SUB_TO_NORMAL) 
        
        # Para mostrar al usuario, necesitamos el unicode (ej. H₂O)
        ecuacion_actual_unicode = self.ecuacion_var.get().strip()
        
        # Revertir la ecuación actual a normal para el proceso de construcción.
        # Esto es clave para trabajar con el string y luego formatear todo de una vez.
        ecuacion_actual_normal = ecuacion_actual_unicode.translate(SUB_TO_NORMAL)
        
        if molecula_normal:
            
            # --- CONSTRUYENDO LA NUEVA ECUACIÓN EN FORMATO NORMAL ---
            if not ecuacion_actual_normal or ecuacion_actual_normal.endswith('→'):
                nueva_ecuacion_normal = ecuacion_actual_normal + " " + molecula_normal
            elif ecuacion_actual_normal.endswith('+ '):
                # Esto maneja casos donde '→' fue agregado y había un '+' sobrante
                nueva_ecuacion_normal = ecuacion_actual_normal[:-2] + " + " + molecula_normal
            else:
                nueva_ecuacion_normal = ecuacion_actual_normal + " + " + molecula_normal
            
            # --- APLICAR SUBÍNDICES AL RESULTADO PARA MOSTRARLO ---
            # Usamos self.aplicar_subindices para formatear correctamente la ecuación completa
            ecuacion_a_mostrar = self.aplicar_subindices(nueva_ecuacion_normal.strip())
            
            # Actualizamos el Entry de la Ecuación con el formato Unicode
            self.ecuacion_var.set(ecuacion_a_mostrar)
            
            # Limpiamos el campo de la molécula para la siguiente entrada
            self.molecula_var.set("")
            
    def agregar_flecha(self):
        """
        Añade la flecha '→' al campo de la ecuación.
        *** Mantiene los subíndices en la parte existente. ***
        """
        ecuacion_actual_unicode = self.ecuacion_var.get().strip()
        
        if not ecuacion_actual_unicode.endswith('→'):
            # Revertir temporalmente a normal para la lógica de limpieza de '+'
            ecuacion_actual_normal = ecuacion_actual_unicode.translate(SUB_TO_NORMAL)
            
            if ecuacion_actual_normal.endswith('+'):
                 ecuacion_actual_normal = ecuacion_actual_normal[:-1]
            elif ecuacion_actual_normal.endswith('+ '):
                 ecuacion_actual_normal = ecuacion_actual_normal[:-2]
                 
            # Reaplicar subíndices y añadir la flecha
            parte_limpia_unicode = self.aplicar_subindices(ecuacion_actual_normal.strip())
            
            self.ecuacion_var.set(parte_limpia_unicode + " → ")
            self.molecula_var.set("")

    def limpiar_ecuacion(self):
        """Limpia el campo de la ecuación."""
        self.ecuacion_var.set("")
        self.molecula_var.set("") # Limpiar también el campo de molécula
        self.output_text.delete(1.0, tk.END)

    def balancear_ecuacion(self):
        """Llama al motor de balanceo y muestra el resultado."""
        # Para balancear, usamos el texto del Entry, pero lo convertimos a NORMAL
        ecuacion_unicode_str = self.ecuacion_var.get().strip()
        ecuacion_str = ecuacion_unicode_str.translate(SUB_TO_NORMAL)
        
        self.output_text.delete(1.0, tk.END)
        
        if not ecuacion_str or '→' not in ecuacion_str:
            messagebox.showerror("Error de Formato", "Por favor, introduce una ecuación química válida con reactivos, flecha (→) y productos.")
            return

        try:
            # 1. Parsear la ecuación
            reactivos_str, productos_str = [s.strip() for s in ecuacion_str.split('→')]
            # El parseo utiliza la versión NORMAL de la molécula
            reactivos = [parsear_ecuacion(s.strip()) for s in reactivos_str.split('+')]
            productos = [parsear_ecuacion(s.strip()) for s in productos_str.split('+')]

            # 2. Inicializar el balanceador
            balanceador = BalanceadorEcuacion(reactivos, productos)
            
            # 3. Mostrar el procedimiento inicial
            self.output_text.insert(tk.END, "1. Asignamos variables:\n")
            ecuacion_con_variables = balanceador.obtener_ecuacion_con_variables()
            # Muestra el procedimiento con subíndices
            self.output_text.insert(tk.END, self.aplicar_subindices(ecuacion_con_variables) + "\n\n")

            # 4. Obtener la matriz de coeficientes y los sistemas de ecuaciones
            matriz, elementos = balanceador.construir_matriz()
            
            self.output_text.insert(tk.END, "2. Ecuaciones por elemento:\n")
            for i, elem in enumerate(elementos):
                ecuacion = balanceador.obtener_ecuacion_texto(elem, matriz[i])
                self.output_text.insert(tk.END, f"  {elem}: {ecuacion}\n")
            self.output_text.insert(tk.END, "\n")
            
            # 5. Resolver el sistema y obtener los coeficientes
            coeficientes = balanceador.resolver()
            
            self.output_text.insert(tk.END, "3. Resolución del sistema:\n")
            if not coeficientes:
                self.output_text.insert(tk.END, "  Error: No se encontró solución entera simple o la ecuación es trivial/inválida.\n")
                return

            self.output_text.insert(tk.END, f"  Coeficientes fraccionarios/decimales: {coeficientes}\n")
            
            # 6. Minimizar y mostrar resultado final
            coeficientes_enteros = balanceador.minimizar_coeficientes(coeficientes)
            self.output_text.insert(tk.END, f"  Coeficientes enteros mínimos: {coeficientes_enteros}\n\n")

            ecuacion_balanceada = balanceador.formatear_ecuacion_balanceada(coeficientes_enteros)
            
            # 7. Formatear a subíndices para la presentación final
            ecuacion_sub = self.aplicar_subindices(ecuacion_balanceada)
            
            self.output_text.insert(tk.END, "4. Ecuación Balanceada:\n")
            self.output_text.insert(tk.END, f"  {ecuacion_sub}", ('balanceada',))
            
            # Estilo para el resultado final
            self.output_text.tag_config('balanceada', font=('Consolas', 12, 'bold'), foreground="#0D47A1")

        except ValueError as e:
            messagebox.showerror("Error de Parseo", str(e))
        except Exception as e:
            messagebox.showerror("Error Desconocido", f"Ocurrió un error inesperado durante el balanceo: {e}")

    def aplicar_subindices(self, texto):
        """
        Convierte los números de las moléculas a subíndices unicode, 
        pero mantiene los coeficientes (números al inicio) grandes.
        
        Nota: Esta función espera recibir el texto en formato NORMAL (sin subíndices).
        """
        partes = texto.split()
        resultado = []
        for parte in partes:
            
            if parte in ('+', '→'):
                resultado.append(parte)
                continue
            
            # 1. Separar coeficiente (si existe) y molécula
            match = re.match(r'^(\d*)(.*)$', parte)
            
            if match:
                coef = match.group(1) # Coeficiente, se mantiene normal
                mol = match.group(2)  # Molécula
                
                # 2. Aplicar subíndices solo a la parte de la molécula
                mol_subscripted = mol.translate(NORMAL_TO_SUB)
                
                # 3. Recomponer (Coeficiente normal + Molécula con subíndice)
                resultado.append(coef + mol_subscripted)
            else:
                 # Si no hay match (solo es un símbolo de elemento, por ejemplo), no hacemos nada
                 resultado.append(parte)
                 
        return " ".join(resultado)
        
# ----------------------------------------------------
# FUNCIÓN DE INICIO REQUERIDA POR ui/main.py
# ----------------------------------------------------
def iniciar_interfaz():
    """Función wrapper para iniciar la clase Interfaz."""
    app = Interfaz()
    app.mainloop()

if __name__ == '__main__':
    iniciar_interfaz()